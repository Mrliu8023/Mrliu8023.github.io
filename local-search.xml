<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vim for Gopher</title>
    <link href="/2021/04/18/vim/"/>
    <url>/2021/04/18/vim/</url>
    
    <content type="html"><![CDATA[<h1 id="Vim-for-Gopher"><a href="#Vim-for-Gopher" class="headerlink" title="Vim for Gopher"></a>Vim for Gopher</h1><p>vim配置golang开发环境。</p><h2 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h2><h3 id="1-下载vim8"><a href="#1-下载vim8" class="headerlink" title="1. 下载vim8"></a>1. 下载vim8</h3><p>地址：<a href="https://github.com/vim/vim/releases">https://github.com/vim/vim/releases</a></p><p>我选择的是GitHub的最新版本，直接wget进行下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/vim/vim/archive/refs/tags/v8.2.2756.zip<br></code></pre></td></tr></table></figure><p>下载到目录后解压。</p><h3 id="2-编译安装"><a href="#2-编译安装" class="headerlink" title="2. 编译安装"></a>2. 编译安装</h3><p>进入解压目录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">./configure \<br>--enable-multibyte \<br>--enable-perlinterp=dynamic \<br>--enable-rubyinterp=dynamic \<br>--with-ruby-command=/opt/homebrew/opt/ruby/bin/ruby \<br>--enable-pythoninterp=dynamic \<br>--with-python-config-dir=/usr/lib/python2.7/config \<br>--enable-python3interp \<br>--with-python3-config-dir=/opt/homebrew/Cellar/python@3.9/3.9.4/Frameworks/Python.framework/Versions/Current/lib/python3.9/config-3.9-darwin/ \<br>--enable-luainterp \<br>--with-lua-prefix=/opt/homebrew/opt/lua@5.3 \<br>--enable-cscope \<br>--enable-gui=auto \<br>--with-features=huge \<br>--enable-fontset \<br>--enable-largefile \<br>--disable-netbeans \<br>--enable-fail-if-missing \<br>--prefix=/usr/local/vim8<br></code></pre></td></tr></table></figure><p>其中，注意有几个参数需要自定义配置</p><ul><li>ruby</li><li>lua</li><li>python</li></ul><p>平台不同，各自的路径配置不同。</p><p>执行成功后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>安装vim。</p><h3 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3. 配置环境变量"></a>3. 配置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;PATH=/usr/local/vim8/bin:$PATH&quot; &gt;&gt; ~/.bashrc<br>source ~/.bashrc<br>// zsh<br>echo &quot;PATH=/usr/local/vim8/bin:$PATH&quot; &gt;&gt; ~/.zshrc<br>source ~/.zshrc<br></code></pre></td></tr></table></figure><h2 id="配置vimrc"><a href="#配置vimrc" class="headerlink" title="配置vimrc"></a>配置vimrc</h2><ol><li><p>安装Vundle.vim</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p ~/.vim/bundle<br>git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim<br></code></pre></td></tr></table></figure><p>新建并编辑<code>~/.vimrc</code>文件，在文件顶部添加Vundle.vim的配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">set nocompatible              &quot; be iMproved, required<br>filetype off                  &quot; required<br><br>&quot; set the runtime path to include Vundle and initialize<br>set rtp+=~/.vim/bundle/Vundle.vim<br>call vundle#begin()<br><br>&quot; let Vundle manage Vundle, required<br>Plugin &#x27;gmarik/Vundle.vim&#x27;<br><br>&quot; All of your Plugins must be added before the following line<br>call vundle#end()            &quot; required<br>filetype plugin indent on    &quot; required<br></code></pre></td></tr></table></figure></li><li><p>安装vim-go</p><p>安装vim-go需要golang环境，请保证你的开发环境装了go。</p><p>编辑~/.vimrc，在vundle#begin和vundle#end间增加一行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Plugin</span> <span class="hljs-string">&#x27;fatih/vim-go&#x27;</span><br></code></pre></td></tr></table></figure><p>在vim内执行<code>PluginInstall</code>安装plugin.</p><p>待vim-go安装完毕之后安装Go Tools二进制,打开vim，在vim内执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">:GoInstallBinaries<br></code></pre></td></tr></table></figure><p>通过<code>:GoInstallBinaries</code>，这些vim-go依赖的二进制工具将会自动被下载，并被安装到<code>$GOBIN</code>下或<code>$GOPATH/bin</code>下。（这个工具需要依赖git或hg，需要提前安装到你的OS中。）</p></li><li><p>安装YCM</p><p>同vim-go一样，在~/.vimrc中添加一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Plugin &#x27;Valloric/YouCompleteMe&#x27;<br></code></pre></td></tr></table></figure><p>保存退出后，再打开~/.vimrc并执行<code>PluginInstall</code>。</p><p>不同平台参照安装文档引导安装编译。<a href="https://github.com/ycm-core/YouCompleteMe#installation">https://github.com/ycm-core/YouCompleteMe#installation</a></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Memory Model</title>
    <link href="/2021/02/23/Go-Memory-Model/"/>
    <url>/2021/02/23/Go-Memory-Model/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-Memory-Model"><a href="#Go-Memory-Model" class="headerlink" title="Go Memory Model"></a>Go Memory Model</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>如何保证在一个goruntine中看到在另一个goroutine修改的变量的值</p><p>如果程序中修改数据时有其他goroutine同时读取，那么必须将读取串行化。为了串行化访问，请使用channel或其他同步原语，例如sync和sync/atomic来保护数据。</p><h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h2><p>在一个gouroutine中，读和写一定是按照程序中的顺序执行的。即编译器和处理器只有在不会改变这个goroutine的行为时才可能修改读和写的执行顺序。<strong>由于重排，不同的goroutine可能会看到不同的执行顺序。</strong>例如，一个goroutine执行<code>a = 1;b = 2;</code>，另一个goroutine可能看到<code>b</code>在<code>a</code>之前更新。</p><p>为了说明读和写的必要条件，我们定义了<code>先行发生（Happens Before）</code>–Go程序中执行内存操作的偏序。如果事件<code>e1</code>发生在<code>e2</code>前，我们可以说<code>e2</code>发生在<code>e1</code>后。如果<code>e1</code>不发生在<code>e2</code>前也不发生在<code>e2</code>后，我们就说<code>e1</code>和<code>e2</code>是并发的。</p><h3 id="内存重排"><a href="#内存重排" class="headerlink" title="内存重排"></a>内存重排</h3><ul><li>CPU重排</li></ul><p><a href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE">MESI</a></p><ul><li>编译器重排</li></ul><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>程序的初始化在单独的goroutine中进行，但这个goroutine可能会创建出并发执行的其他goroutine。</p><p><em>If a package <code>p</code> imports package <code>q</code>, the completion of <code>q</code>‘s <code>init</code> functions happens before the start of any of <code>p</code>‘s.</em></p><p><em>The start of the function <code>main.main</code> happens after all <code>init</code> functions have finished.</em></p><p><strong><em>如果包p引入（import）包q，那么q的init函数的结束先行发生于p的所有init函数开始</em></strong> 。</p><p><strong><em>main.main函数的开始发生在所有init函数结束之后</em></strong></p><h3 id="创建goroutine"><a href="#创建goroutine" class="headerlink" title="创建goroutine"></a>创建goroutine</h3><p>The go statement that starts a new goroutine happens before the goroutine’s execution begins.</p><p>启动一个goroutine的语句先行发生于goroutine的执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// will print &quot;Hello, World&quot; at some point in the future (perhaps after main has returned)</span><br>a := <span class="hljs-string">&quot;Hello World&quot;</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">print</span>(a)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>will print “Hello, World” at some point in the future (perhaps after <em>main</em> has returned)</p><h3 id="销毁goroutine"><a href="#销毁goroutine" class="headerlink" title="销毁goroutine"></a>销毁goroutine</h3><p>gouroutine的退出并不会保证先行发生于程序的任何事件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; a = <span class="hljs-string">&quot;hello&quot;</span> &#125;()<br><span class="hljs-built_in">print</span>(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>对变量<code>a</code> 的赋值之后没有任何同步事件，所以不能保证变量<code>a</code> 对其他goroutine可见。实际上，一个激进的编译器可能会删掉整个<code>go</code> 语句。</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>channel通信是goroutine同步的主要方法。每一个在特定channel的发送操作都会匹配到通常在另一个goroutine执行的接收操作。</p><ul><li><em>A send on a channel happens before the corresponding receive from that channel completes.</em></li></ul><p><em>对channel的发送操作先行发生于<strong>对应的</strong>接收操作完成。</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>a = <span class="hljs-string">&quot;hello, world&quot;</span><br>c &lt;- <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> f()<br>&lt;-c<br><span class="hljs-built_in">print</span>(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段程序保证了变量<code>a</code> 的赋值的可见性。<code>a</code>的赋值先行发生于<code>c &lt;- 0</code>，<code>c &lt;- 0</code>先行发生于<code>&lt;-c</code>，<code>&lt;-c</code>先行发生于<code>print(a)</code>,所以<code>a</code>的赋值先行发生于<code>print(a)</code> 。</p><ul><li><em>The closing of a channel happens before a receive that returns a ze ro value because the channel is closed.</em></li></ul><p><em>一个<code>channel</code>的关闭先行发生于它接收到一个零值，因为它已经关闭了。</em></p><p>在上面的例子中，将<code>c &lt;- 0</code>替换为<code>close(c)</code>还会产生同样的结果。</p><ul><li><em>A receive from an unbuffered channel happens before the send on that channel completes.</em></li></ul><p><em>无缓冲<code>channel</code>的接收先行发生于发送完成.</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>a = <span class="hljs-string">&quot;hello, world&quot;</span><br>&lt;-c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> f()<br>c &lt;- <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(a)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><em>The kth receive on a channel with capacity C happens before the k+Cth send from that channel completes.</em></li></ul><p><em>在容量为C的channel上的第k个接收先行发生于从这个channel上的第k+C次发送完成。</em></p><p>这条规则将前面的规则推广到了带缓冲的channel上。可以通过带缓冲的channel来实现计数信号量：channel中的元素数量对应着活动的数量，channel的容量表示同时活动的最大数量，发送元素获取信号量，接收元素释放信号量，这是限制并发的通常用法。</p><p>下面程序为<code>work</code>中的每一项开启一个goroutine，但这些goroutine通过有限制的channel来确保最多同时执行三个工作函数（w）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> limit = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, w := <span class="hljs-keyword">range</span> work &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w <span class="hljs-keyword">func</span>()</span>)</span> &#123;<br>limit &lt;- <span class="hljs-number">1</span><br>w()<br>&lt;-limit<br>&#125;(w)<br>&#125;<br><span class="hljs-keyword">select</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>sync包实现了两个锁的数据类型<code>sync.Mutex</code>和<code>sync.RWMutex</code>。</p><ul><li><em>For any sync.Mutex or sync.RWMutex variable l and n &lt; m, call n of l.Unlock() happens before call m of l.Lock() returns.</em></li></ul><p><em>对任意的sync.Mutex或sync.RWMutex变量l和n &lt; m，n次调用l.Unlock()先行发生于m次l.Lock()返回。</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> l sync.Mutex<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>a = <span class="hljs-string">&quot;hello, world&quot;</span><br>l.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>l.Lock()<br><span class="hljs-keyword">go</span> f()<br>l.Lock()<br><span class="hljs-built_in">print</span>(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>能保证打印出”hello, world”。第一次调用l.Unlock()（在f()中）先行发生于main中的第二次l.Lock()返回, 先行发生于print。</p><ul><li><em>For any call to l.RLock on a sync.RWMutex variable l, there is an n such that the l.RLock happens (returns) after call n to l.Unlock and the matching l.RUnlock happens before call n+1 to l.Lock.</em></li></ul><p><em>对于sync.RWMutex变量l，任意的函数调用l.RLock满足第n次l.RLock<strong>后发生于</strong>第n次调用l.Unlock，对应的l.RUnlock先行发生于第n+1次调用l.Lock。</em></p><h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>sync包的Once为多个goroutine提供了安全的初始化机制。能在多个线程中执行once.Do(f)，但只有一个f()会执行，其他调用会一直阻塞直到f()返回。</p><p><em>A single call of f() from <a href="http://once.do/">once.Do</a>(f) happens (returns) before any call of <a href="http://once.do/">once.Do</a>(f) returns.</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">string</span><br><span class="hljs-keyword">var</span> once sync.Once<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span> &#123;<br>a = <span class="hljs-string">&quot;hello, world&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doprint</span><span class="hljs-params">()</span></span> &#123;<br>once.Do(setup)<br><span class="hljs-built_in">print</span>(a)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoprint</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> doprint()<br><span class="hljs-keyword">go</span> doprint()<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>twoprint</code>会打印*”hello, world”*两次。<code>setup</code>只在第一次<code>doprint</code>时执行。</p><h3 id="错误的同步方法"><a href="#错误的同步方法" class="headerlink" title="错误的同步方法"></a>错误的同步方法</h3><p>注意，读操作*<strong>r**<em>可能会看到并发的写操作</em></strong>w*<strong>。即使这样也不能表明**<em>r</em></strong>之后的读能看到**<em>w**</em>之前的写。</p><p>如下程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a, b <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>a = <span class="hljs-number">1</span><br>b = <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-built_in">print</span>(a)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> f()<br>g()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>g</code>可能先打印出2然后是0。</p><p><img src="D:\go\src\CS-Study\pics\golang\Go-Memory-Model.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>embed in go</title>
    <link href="/2021/02/23/embed-in-go/"/>
    <url>/2021/02/23/embed-in-go/</url>
    
    <content type="html"><![CDATA[<h1 id="pkg-embed-in-go"><a href="#pkg-embed-in-go" class="headerlink" title="pkg embed in go"></a>pkg embed in go</h1><p>embed包 提供了访问正在运行的go程序的功能。</p><ul><li>嵌入一个文件到string</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;embed&quot;</span><br><br><span class="hljs-comment">//go:embed hello.txt</span><br><span class="hljs-keyword">var</span> s <span class="hljs-keyword">string</span><br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><ul><li>嵌入一个文件到一个字节切片</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;embed&quot;</span><br><br><span class="hljs-comment">//go:embed hello.txt</span><br><span class="hljs-keyword">var</span> b []<span class="hljs-keyword">byte</span><br><span class="hljs-built_in">print</span>(<span class="hljs-keyword">string</span>(b))<br></code></pre></td></tr></table></figure><ul><li>嵌入一个或多个文件作为一个文件系统</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;embed&quot;</span><br><br><span class="hljs-comment">//go:embed hello.txt</span><br><span class="hljs-keyword">var</span> f embed.FS<br>data, _ := f.ReadFile(<span class="hljs-string">&quot;hello.txt&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-keyword">string</span>(data))<br></code></pre></td></tr></table></figure><h2 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h2><p>变量声明上面的<code>go:embed</code>指令使用一个或多个路径指定要嵌入的文件。匹配模式。</p><p>该指令必须紧接在包含单个变量声明的行之前。 指令和声明之间仅允许使用<strong>空行</strong>和**<code>//</code>**行注释。</p><p>变量的类型必须是这三种的其中一个<code>string</code>, <code>[]byte</code>, <code>FS</code>(或者FS的别名)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> server<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;embed&quot;</span><br><br><span class="hljs-comment">// content holds our static web server content.</span><br><span class="hljs-comment">//go:embed image/* template/*</span><br><span class="hljs-comment">//go:embed html/index.html</span><br><span class="hljs-keyword">var</span> content embed.FS<br></code></pre></td></tr></table></figure><p><code>//go:embed</code>指令为简洁起见接受多个空格分隔的模式，但它也可以重复，以避免有许多模式时出现很长的行。模式是相对于包含源文件的包目录进行解释的。即使在windows上，路径分隔符也是<code>/</code>(forward slash)。模式不能包含<code>.</code>或<code>..</code>或空路径元素，也不能以<code>/</code>开头或者结尾。使用<code>*</code>来匹配当前路径下的所有内容。为了允许命名名称中有空格的文件，可以将模式写为Go的双引号<code>&quot;&quot;</code>或者反引号```` ``字符串文本</p><p>如果一个模式命名为一个目录，则该目录下的子树中所有文件都将被递归嵌入，但是名称以<code>.</code>（隐藏文件）或<code>\</code>开头的文件除外。所以上面例子中的变量几乎等价于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// content is our static web server content.</span><br><span class="hljs-comment">//go:embed image template html/index.html</span><br><span class="hljs-keyword">var</span> content embed.FS<br></code></pre></td></tr></table></figure><p>区别就是<code>image/*</code>嵌入了<code>image/.tempfile</code>,但是<code>image</code>没有。</p><p><code>//go:embed</code>指令可以与导出和未导出的变量一起使用，具体取决于软件包是否希望使数据可用于其他软件包。 它只能与程序包范围的全局变量一起使用，而<strong>不能与局部变量一起使用</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Partial</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//go:embed test.txt</span><br>    vat a <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编译将会报错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:embed only allowed in Go files that import &quot;embed&quot;</span><br></code></pre></td></tr></table></figure><p>模式不得与包模块外部的文件匹配，例如<code> .git/*</code>或符号链接。 空目录的匹配将被忽略。 之后，<code>//go:embed</code>行中的每个模式必须至少匹配一个文件或非空目录。</p><p>如果<strong>任何模式无效或匹配无效</strong>，则构建将失败。</p><h3 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h3><p><code>FS</code>实现了<code>io/fs</code>包的<code>FS</code>接口，所以它能在任何理解文件系统的包内使用,包括<code>net/http</code>, <code>text/template</code>, 和<code>html/template</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">http.Handle(<span class="hljs-string">&quot;/static/&quot;</span>,http.StripPrefix(<span class="hljs-string">&quot;/static/&quot;</span>,http.FileServer(http.FS(content))))<br><br>template.ParseFS(content, <span class="hljs-string">&quot;*.tmpl&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="无效模式"><a href="#无效模式" class="headerlink" title="无效模式"></a>无效模式</h2><p><a href="https://github.com/golang/go/issues/44486">https://github.com/golang/go/issues/44486</a></p><p>embed的有效文件名不能为<code>.git</code>, <code>.hg</code>, <code>.bzr</code>, <code>.svn</code>，并且不能包含<code>* &lt; &gt; ? ` &#39; | / \ : </code>等在某些Shell或操作系统中具有特殊含义的符号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// isBadEmbedName reports whether name is the base name of a file that</span><br><span class="hljs-comment">// can&#x27;t or won&#x27;t be included in modules and therefore shouldn&#x27;t be treated</span><br><span class="hljs-comment">// as existing for embedding.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBadEmbedName</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> err := module.CheckFilePath(name); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">switch</span> name &#123;<br><span class="hljs-comment">// Empty string should be impossible but make it bad.</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&quot;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-comment">// Version control directories won&#x27;t be present in module.</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;.bzr&quot;</span>, <span class="hljs-string">&quot;.hg&quot;</span>, <span class="hljs-string">&quot;.git&quot;</span>, <span class="hljs-string">&quot;.svn&quot;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// CheckFilePath checks that a slash-separated file path is valid.</span><br><span class="hljs-comment">// The definition of a valid file path is the same as the definition</span><br><span class="hljs-comment">// of a valid import path except that the set of allowed characters is larger:</span><br><span class="hljs-comment">// all Unicode letters, ASCII digits, the ASCII space character (U+0020),</span><br><span class="hljs-comment">// and the ASCII punctuation characters</span><br><span class="hljs-comment">// “!#$%&amp;()+,-.=@[]^_&#123;&#125;~”.</span><br><span class="hljs-comment">// (The excluded punctuation characters, &quot; * &lt; &gt; ? ` &#x27; | / \ and :,</span><br><span class="hljs-comment">// have special meanings in certain shells or operating systems.)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// CheckFilePath may be less restrictive in the future, but see the</span><br><span class="hljs-comment">// top-level package documentation for additional information about</span><br><span class="hljs-comment">// subtleties of Unicode.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckFilePath</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">if</span> err := checkPath(path, <span class="hljs-literal">true</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;malformed file path %q: %v&quot;</span>, path, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果非要支持带特殊字符的话，可以通过重新编译go二进制来实现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
